# フロントエンド アーキテクチャ戦略
## 技術スタック概要
### アプリケーション
- フロントエンドは**TypeScript**を使用する
  - 型安全性を確保
  - 生成AIとの相性
- ユーザーの画面操作に柔軟に対応するため、リアクティブベースのライブラリ・フレームワークを使用する
  - **React**、**Vue**、**Angular**の覇権争いの勝者である**React**を使用する
  - Reactは公式ページで、**Reactをラップし、バックエンドで起動するフレームワーク**の使用を推奨しているため、左記のフレームワークを使用する
    - **Next.js**は開発チームがReact開発チームと協同で研究開発を行っているためReactに近しく人気も最も高いため、**Next.js**を使用する
- CSSは**Tailwind**を利用する
### インフラ
- アプリケーションのデプロイ先は、Next.jsを開発している**Vercel**を利用する
- CI/CDは、**GitHub Actions**を利用する
- データの保存先は以下とする
  - テキストはリレーショナルデータベースに保存する。リレーショナルデータベースは、WebAPIアプリケーションで**SupaBase**を利用する。そのため、BFFとフロントエンドではテキストの保存については意識しない。
    - 改行コードは文字列として表示されてしまうため、`<p class="whitespace-pre-line">`を用いて改行ありで画面表示する。
  - 画像データはオブジェクトストレージを利用する。オブジェクトストレージは本番環境では**S3**や**Cloudflatre**や**GitHubPages**を利用するが、開発段階ではNext.jsの`/public`を利用する。

## Next.js 基本設定
- **バージョン 15**を使用する
- **App Router**を使用する
  - Next.jsが推奨している
  - 1つのページで、サーバサイドレンダリングとクライアントレンダリングを使い分けることができる
- **/srcをトップディレクトリとしない**
  - Next.jsの公式ページでは、オプションとして扱われており、公式のGitHubのサンプルアプリケーションでも積極的に採用はされていない

## アーキテクチャ
### 概要
- 業務ロジックはBFFは実現せず、バックエンドWebAPIアプリケーションで実現する。そのため、BFFはフロントエンドとバックエンドの中間として機能する。
- `/app`配下はルーティングとUIのみに責務を持ち、フロントエンドロジックの実現やインターネット通信は`/lib`配下で実現する
- コンポーネント志向を重視し、1つのページに閉じたコンポーネントは`page.tsx`と同階層の`_components`ディレクトリに配置する。ただし、複数のページで再利用するコンポーネントは、`/components`に昇格する。
- Next.jsの思想に倣い、データの取得やレンダリングは極力サーバサイドで実現する。ユーザーの入力によって変化するデータの取得や画面についてはクライアントサイドで実現する。
- BFFとの通信については、データ更新・登録・削除などのミューテーションは**Server Actions**で実現する。データの取得はフロントエンド側でキャッシュをする目的で、**Server Actions**を使用せずに**SWR + Axios**で実現する。
### ディレクトリ構成
```
/
├── app
│   ├── page.tsx
│   ├── _components
│   │   ├── ComponentA.tsx
│   │   └── ComponentB.tsx
├── components
│   ├── common
│   │   ├── CommonComponent1.tsx
│   │   └── CommonComponent2.tsx
│   ├── feature1
│   │   ├── FeatureComponent1.tsx
│   │   └── FeatureComponent2.tsx
│   └── feature2
│       ├── FeatureComponent3.tsx
│       └── FeatureComponent4.tsx
├── lib
│   ├── bff
│   │   ├── web-client
│   │   │   ├── bffApiClient.ts
│   │   │   └── bffApiUtils.ts
│   │   ├── server-actions
│   │       ├── action1.ts
│   │       └── action2.ts
│   ├── frontend
│   │   ├── web-client
│   │   │   ├── frontendApiClient.ts
│   │   │   └── frontendApiUtils.ts
│   │   ├── hooks
│   │   │   ├── useCustomHook1.ts
│   │   │   └── useCustomHook2.ts
│   ├── shared
│   │   ├── validation
│   │   ├── utils
│   │   │   ├── util1.ts
│   │   │   └── util2.ts
│   │   └── types
│   │       ├── type1.ts
│   │       └── type2.ts
├── mocks
│   ├── mockData1.ts
│   └── mockData2.ts
```
### WebAPI戦略
- フロントエンドから直接WebAPIアプリケーションを呼び出すのではなく、BFFを経由して呼び出す。BFFを経由することで、フロントエンド側にセキュリティ上の情報（接続先・API鍵）などを持つ必要がなくなり、またBFFのログから利用状況を確認することもできる。
- BFFでのWebAPIはデフォルトでは直列実行になるが、ブラウザへのレスポンス時間を短縮するために、初期表示の際に表示したい情報については`Promise.all()`を用いて並列実行する。他の情報については**遅延ローディング**によってサーバサイドで取得ができ次第順次フロントエンドに連携して表示する。

### WebAPIクライアント
#### フロントエンド
タイムアウトやリトライやエラーハンドリングを備えていないため、Web標準Fetchを利用せず**Axios**を利用する。  
Web標準Fetchをラップしてタイムアウトとリトライとエラーハンドリングを作成することは車輪の再発明であり、メンテナンスコストも必要なため、行わない。トレードオフとして**Axios**に依存することになるが、非常に人気のライブラリでありエコシステムが発展しているため、依存の影響は軽微なものと判断している。
WebAPIクライアントのライブラリには、**Axios**の他に**ky**などのライブラリもあるが、NPMのダウンロード数やエラーハンドリングの充実などを考慮して**Axios**に決定した。
#### BFF
Web標準Fetchを拡張したNext.js独自のFetchを利用する。Next.jsの内部キャッシュと密接にかかわっており、Axiosなどのサードパティでは**ISR**や**タグ付きキャッシュ**が実現できないため。  
トレードオフとして、タイムアウトやリトライやエラーハンドリングの実現が別途必要になるが、**Cockatiel**を利用する。**Cockatiel**は他にもレート制限を実現でき、BFFがAPIゲートウェイの役割を担うことができる。
- 他の選択肢としては**oppposum**がある。GitHub Starの数と推移、BFFとフロントエンドの両方に対応していることを踏まえて、**Cockatiel**を利用する。ただし可搬性を確保するため、ライブラリについてはできるだけ切り出す。
### バリデーション
独自実装するのではなく、デファクトスタンダードである**Zod**と**React Hook Form**を利用する。以前は**Formik + Yup**の組み合わせが主流だったが、**React Hook From + Zod**の組み合わせのほうがパフォーマンス面で優れている。
#### React Hook Form
- Reactのレンダリングパフォーマンスを最適化する設定。フォームの状態をコンポーネント外で管理するため、レンダリングが効率的に行われる。
- 依存関係が非常に少なく、軽量で、最小限のバンドルサイズとなっている。
#### Zod
- 簡潔で直感的なAPIによって、複雑なバリデーションルールを簡単に定義できる
- 型安全：TypeScript向けに設計されており、フォームバリデーションのスキーマを型安全に定義できる
#### デメリット
依存関係が増える、学習曲線、高度なバリデーションやカスタマイズが難しい、エラーメッセージのカスタマイズが困難などの課題があるが、独自実装のコストと比較すると妥協できる。特に前者二つについてはデファクトスタンダードであることを考慮するとデメリットとしては極めて軽微なものと判断する。
### 認証・認可
[Next.jsの公式資料の認証・認可ページ](https://nextjs.org/docs/pages/guides/authentication)で例に挙げられているように、**Cookie**を利用する。
- セキュリティ面１：認証認可情報のブラウザのストレージで管理する場合は**XSS**のリスクがあるが、Cookieで認証認可情報を**HttpOnly**で保管することで、JavaScriptで読込みができなくなり**XSS**への対策となる。
  - WebAPIアプリケーションへのリクエストは必ずBFFを経由するようにすることで、**フロントエンドで別ドメインWebAPIアプリケーションの情報（接続情報、鍵など）を保管する必要がなくなり**、ストレージを利用する動機がなくなる。
- セキュリティ面２：HTTPヘッダーの**SameSite属性**に**Strict**を指定することで、別ドメインからのリクエストにはCookieが含まれないようにする。つまり、**CSRF**への対策となる。
- BFFの仕様：SPAはファーストリクエストの段階で各種ページ情報を渡しているため、以降のリクエストは一部の情報をJavaScriptから取得するだけで良いのに対して、BFFにおいてはページ情報を一切渡していないため、JavaScriptによって情報を取得することができない。つまり、GETでページを表示する際にリクエストにトークンを付与することができない。
#### 実現方法
検討段階中。外部サイトを使わずに自前で実現する手法を考える。
- Auth0
- NextAuth.js
### モック
バックエンドWebAPIアプリケーションが開発できていないため、当面の間はモックを利用する。
#### MSW(Mock Service Worker)
最も利用されているモックであるため、エコシステムの充実度合いを考慮して利用する。