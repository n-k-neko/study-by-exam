# Next.jsのパフォーマンスについて
以下の点からNext.jsをBFFで使用する際のパフォーマンスに懸念があったため調査
- Node.jsはシングルスレッドのランタイム環境
- TypeScript/JavaScriptの処理速度への懸念
  - V8 Isolateを活用した場合でも残る課題
  - 言語自体の実行速度の制約
  - 型チェックのオーバーヘッド

## Node.jsの実行モデル
### シングルスレッドとイベントループ
- シングルスレッド
  - メインスレッド（イベントループ）が1つ
  - 並列処理は不可（マルチスレッドで同時実行できない）
  - 並行処理は可能（非同期処理で順次実行）
- イベントループ
  - 非同期処理の仕組み
  - イベントキューにタスクを追加
  - イベントループがタスクを順次実行
  - 非同期処理は別スレッド（libuv）で実行
    - メインスレッド（イベントループ）は1つ
    - 非同期処理用のワーカースレッドは複数存在
    - libuvのスレッドプールで非同期処理を並列実行

### リクエスト処理の仕組み
- 処理の流れ
  1. HTTPリクエストを受信
  2. 同期処理を実行（リクエストの解析など）
  3. 非同期処理をキューに追加（DBアクセス、外部API呼び出しなど）
  4. イベントループが次のリクエストの処理を開始
  5. 非同期処理が完了したらコールバックを実行
     - 元のリクエストの処理を再開
     - 非同期処理の結果を使用して処理を継続
  6. レスポンスを返す

- 複数リクエストの処理
  - リクエストの並行処理
    - 1つのリクエストの非同期処理中に他のリクエストを処理
    - イベントループがリクエスト間を切り替えながら処理
    - コンテキストスイッチではなく、イベントループによる切り替え
  - リクエストの独立性
    - 各リクエストは独立して処理
    - リクエスト間でメモリは共有
    - 1つのリクエストの処理が長時間かかると他のリクエストに影響
  - 処理の制約
    - 同期処理中は他のリクエストを処理できない
    - 非同期処理中は他のリクエストを処理可能
    - CPUバウンドな処理は全体のパフォーマンスに影響

### 実行モデルの比較
| 項目 | Node.js | Java/Go |
|------|---------|---------|
| スレッドモデル | シングルスレッド | マルチスレッド |
| 並列処理 | 不可 | 可能 |
| 並行処理 | 可能（イベントループ） | 可能（スレッド） |
| メモリ管理 | 完全共有（1スレッド） | スレッドローカルと共有メモリ |
| スレッド同期 | 不要 | 必要（共有メモリ） |
| CPUバウンド処理 | 苦手 | 得意 |
| I/Oバウンド処理 | 得意 | 普通 |
| メモリ使用量 | 少ない | 多い |
| デバッグ | 難しい | 比較的容易 |
| エラーハンドリング | 複雑（非同期、try-catch、Promise、async/await） | スレッド単位（try-catch、例外伝播、スレッドプール） |
| ブロッキング耐性 | 低い（同期処理で全体ブロック） | 高い（スレッド単位でブロック） |
| アイソレーション | 低い（メモリ共有） | 高い（スレッド分離） |
| Graceful Restart | 不可（シングルスレッド） | 可能（メインスレッドによる移行） |
| ガベージコレクション | 世代別GC（V8） | 並行マーキング（JVM/Go） |

### 用語の説明
- スレッド同期
  - 複数のスレッドが共有リソースにアクセスする際の競合を防ぐ仕組み
  - ロック、セマフォ、ミューテックスなどの同期機構を使用
  - マルチスレッド環境では必須だが、オーバーヘッドが発生

- コンテキストスイッチ
  - 実行中のスレッドを切り替える際の処理
  - スレッドの状態（レジスタ、メモリマップなど）を保存・復元
  - 切り替えのオーバーヘッドが発生し、パフォーマンスに影響

- バウンド処理
  - CPUバウンド：CPUの処理能力がボトルネックとなる処理（計算処理など）
  - I/Oバウンド：入出力処理がボトルネックとなる処理（ファイル操作、ネットワーク通信など）
  - 処理の特性に応じて適切な実行モデルを選択する必要がある

- メモリ管理
  - シングルスレッド環境（Node.js）
    - メモリ空間が完全に共有される
    - 同期機構が不要でシンプル
    - メモリリークの影響
      - 1つのリクエストでメモリリークが発生すると、そのプロセス全体に影響
      - メモリ使用量が増加し続け、最終的にプロセスがクラッシュ
      - 他のリクエストの処理にも影響が及ぶ
    - デバッグが比較的容易（状態が1つ）
  - マルチスレッド環境（Java/Go）
    - メモリ管理の種類
      - スレッドローカルメモリ：スレッド固有のメモリ空間
      - 共有メモリ：スレッド間で共有されるメモリ空間
    - 同期機構による保護が必要（共有メモリ）
    - メモリリークの影響
      - スレッドローカルメモリのリーク：そのスレッドのみに影響
      - 共有メモリのリーク：複数のスレッドに影響が及ぶ可能性
    - デバッグが複雑（状態が複数）

- ブロッキング耐性
  - 処理が待ち状態になった際の他の処理への影響度
  - シングルスレッド環境：1つの処理がブロックすると全体に影響
  - マルチスレッド環境：スレッド単位でブロックが局所化され、他のスレッドは影響を受けない
  - システムの応答性とスループットに影響

- アイソレーション
  - 処理の独立性と分離の度合い
  - メモリ空間の分離、エラーの影響範囲、リソースの共有度
  - 高いアイソレーションは安定性と信頼性を向上させる

- Graceful Restart
  - プロセス再起動時に接続を維持する仕組み
  - マルチスレッド環境：メインスレッドが新しいプロセスを起動し、古いプロセスの接続を移行
  - シングルスレッド環境：再起動時に瞬断が発生し、接続の維持が不可
  - 高可用性を実現するための重要な機能

- ガベージコレクション
  - V8（Node.js）のGC
    - メインスレッドをブロックするSTWが発生
    - 世代別GCによる効率的なメモリ管理
      - 若いオブジェクトは頻繁にGC
      - 古いオブジェクトはGC頻度を下げる
    - シンプルな実装で軽量
  - JVM/GoのGC
    - メインスレッドをブロックするSTWが発生
    - 並行マーキングなどの最適化技術
      - マーキングフェーズを並行実行
      - より複雑な実装が必要
    - メモリ使用量が増加

- ノンブロッキングI/O
  - I/O操作の待ち時間中も他の処理を実行可能
  - Node.jsの基本設計思想
    - すべてのI/O操作は非同期で実行
    - コールバック、Promise、async/awaitで結果を処理
    - イベントループによる効率的なリソース管理
  - メリット
    - I/O待ち時間を有効活用
    - リソースの効率的な利用
    - 高いスループットの実現
  - デメリット
    - コールバック地獄の可能性
    - エラーハンドリングの複雑さ
    - デバッグの難しさ

- エラーハンドリング
  - Node.js
    - 非同期処理の特性
      - コールバックでのエラー伝播
      - Promiseのreject/catch
      - async/awaitのtry-catch
    - エラー伝播の複雑さ
      - 非同期処理の連鎖による伝播
      - エラーの種類による処理の分岐
      - グローバルエラーハンドリングの必要性
  - Java/Go
    - 同期的な例外処理
      - try-catchによる直接的な例外処理
      - 例外の型による処理の分岐
      - スタックトレースの明確さ
    - スレッド単位のエラー処理
      - スレッド固有の例外ハンドリング
      - スレッドプールでのエラー処理
      - エラーの影響範囲の明確さ

### Node.jsの特徴
#### 強み
- I/Oバウンドな処理に強い
  - ノンブロッキングI/O
  - 効率的なリソース利用
  - スケーラビリティが高い
    - C10K問題への対応
      - C10K問題とは
        - [いまさら聞けないNode.js](https://knowledge.sakura.ad.jp/24148/)
        - 1万台のクライアントからの同時接続を処理する課題
        - 従来のスレッドベースのモデルでは1接続1スレッドで非効率
        - メモリ使用量とコンテキストスイッチのオーバーヘッドが問題
      - Node.jsの解決策
        - 1つのプロセスで多数の同時接続を処理可能
        - スレッドベースのモデルと比較してメモリ使用量が少ない
        - イベントループによる効率的なリソース管理
- メモリ効率が良い
  - スレッド間の同期が不要
  - メモリ使用量が少ない
  - コンテキストスイッチのオーバーヘッドがない

#### 弱み
- CPUバウンドな処理が苦手
  - シングルスレッドの制約
    - 同期処理中は次のリクエストを処理できない
    - 重い計算処理はメインスレッドをブロック
    - 処理時間が長いと他のリクエストが待たされる
  - マルチコアを活かせない
  - 1つの処理が長時間かかると全体に影響
  - 対策
    - Worker Threads
      - libuvのスレッドプールを利用
      - メインスレッド（イベントループ）とは別のスレッドで実行
      - スレッド間通信はメッセージパッシング
      - ただし、以下の課題がある
        - TypeScript/JavaScriptの実行速度の制約は変わらない
        - スレッド間通信のオーバーヘッドが大きい
        - メモリ使用量が増加
        - デバッグが複雑化
        - 実装の複雑さが増加
    - WebAssembly
      - C++などのネイティブコードをコンパイルして実行
      - V8エンジン上でネイティブに近い性能を実現
      - メモリ管理が効率的
      - ただし、以下の課題がある
        - 実装の複雑さが非常に高い
        - デバッグが困難
        - 型システムの違いによる問題
        - メモリ管理の複雑さ
        - 学習コストが高い
        - 既存コードの移行が困難
  - 推奨される方針
    - パフォーマンスが重要な処理は別の言語/フレームワークで実装
    - マイクロサービスアーキテクチャの採用
    - 処理の分散化と適切な技術選定

- メモリ管理の制約
  - メモリ空間は共有
  - クラッシュの影響は全体に及ぶ
  - メモリリークの影響
    - すべてのリクエストに影響が及ぶ
    - メモリ使用量が徐々に増加
    - 最終的にプロセス全体がクラッシュ
- デバッグの難しさ
  - 非同期処理の追跡が困難
  - スタックトレースが分かりにくい
  - エラーハンドリングが複雑

#### V8 Isolateによる課題解決
- V8 Isolateとは
  - V8エンジンの独立したインスタンス
  - 独自のJavaScriptヒープとガベージコレクション
  - スレッド間で完全に分離された実行環境
  - メモリ空間の完全な分離

- アーキテクチャの根本的な違い
  - シングルスレッド前提の設計
    - イベントループを中心とした設計
    - 非同期処理の最適化
    - シンプルなメモリ管理
    - デバッグの容易さ
  - マルチスレッドへの移行による課題
    - 既存の非同期処理モデルとの競合
    - スレッド管理のオーバーヘッド
    - 同期機構の実装コスト
    - デバッグの複雑化
  - デフォルトでマルチスレッドな言語との比較
    - Java/Goの設計思想
      - スレッドを前提とした設計
      - 効率的なスレッド管理
      - 最適化された同期機構
      - スレッドプールの活用
    - 性能の差
      - スレッド管理のオーバーヘッド
      - 同期機構の実装効率
      - メモリ管理の最適化
      - コンパイル時の最適化
    - 開発効率の差
      - デバッグの容易さ
      - エラーハンドリングの簡潔さ
      - ツールの充実度
      - ドキュメントの充実度

- 評価と結論
  - V8 Isolateの限界
    - シングルスレッド前提の設計からの移行は非効率
    - デフォルトでマルチスレッドな言語と比較して性能が劣る
    - 実装の複雑さが増加する割に得られるメリットが限定的
  - フレームワークごとの状況
    - Next.js
      - 現時点ではV8 Isolateを直接利用できない
      - フレームワークのアーキテクチャがNode.jsのシングルスレッドモデルを前提
      - 既存の非同期処理モデル（イベントループ）との互換性が必要
      - フレームワーク全体の大きな変更が必要
    - Express
      - 理論的にはV8 Isolateを利用可能
      - ただし、実装の複雑さとパフォーマンスの課題は同様
      - 既存のミドルウェアとの互換性の問題
      - セッション管理の複雑化
    - その他のNode.jsフレームワーク
      - 同様の課題が存在
      - フレームワークの設計思想に依存
      - 実装の複雑さとパフォーマンスのトレードオフ
  - 代替アプローチの検討
    - Worker Threadsの活用
      - 既存の非同期処理モデルを維持
      - 特定の処理のみを並列化
      - 実装の複雑さを最小限に抑制
    - WebAssemblyの活用
      - 計算処理の最適化
      - ネイティブに近い性能の実現
      - メモリ管理の効率化
  - 推奨される方針
    - V8 Isolateの採用は見送り
    - 既存の非同期処理モデルを活かした最適化
    - 必要に応じてWorker ThreadsやWebAssemblyを活用
    - パフォーマンスが重要な処理は別の言語/フレームワークで実装

### 運用面での注意点
- プロセス管理
  - PM2などのプロセスマネージャーの使用が推奨
  - クラッシュ時の自動再起動
  - メモリ使用量の監視
  - ログ管理
- メモリリーク対策
  - 定期的なプロセス再起動
  - メモリ使用量の監視
  - リークの早期発見と対応
- 再起動時の制約
  - シングルスレッドのためGraceful Restartが不可
    - マルチスレッド環境との比較
      - マルチスレッド：メインスレッドが新しいプロセスを起動し、古いプロセスの接続を移行
      - Node.js：プロセス再起動時に瞬断が発生
  - プロセス再起動時に瞬断が発生
  - ロードバランサーによる冗長構成が必要

### Next.js
#### アーキテクチャ上の制約
- Node.jsのシングルスレッドモデルを継承
- 非同期処理モデルに依存
- メモリ管理の制約
- CPUバウンド処理の制限

#### 大規模アプリケーションでの課題
- 業務ロジックの実装における制約
  - 複雑な計算処理の非効率性
  - メモリ使用量の増加リスク
  - デバッグの複雑化

#### 推奨アーキテクチャ
- マイクロサービスアーキテクチャの採用
  - 業務ロジックの分離
    - 計算処理は別のサービスで実装
    - 適切な言語/フレームワークの選択
  - Next.jsの役割
    - APIゲートウェイ
    - ルーティング
    - セッション管理
    - キャッシュ制御
    - データ取得とサーバーサイドレンダリング
      - サーバーサイドでのデータ取得
      - クライアントへのJavaScriptバンドルサイズ削減
      - SEO対策
      - 高速な初期表示
  - サービス間通信
    - メッセージキュー
    - gRPC
    - REST API

#### 適している用途
- APIの集約
- 認証/認可
- データの加工

#### 注意が必要な用途
- 重い計算処理
- 長時間の処理
- メモリを大量に使用する処理

## Node.js, TypeScriptの実行速度
### パフォーマンスの差
| 項目 | Node.js/TypeScript | Java | Go |
|------|-------------------|------|-----|
| 計算処理 | 基準値 | 2-3倍高速 | 3-4倍高速 |
| メモリ使用量 | 基準値 | 1.5-2倍 | 0.8-1倍 |
| 起動時間 | 基準値 | 2-3倍 | 0.5-0.8倍 |
| 並列処理 | 制限あり（Worker Threads） | 効率的 | 非常に効率的 |
| メモリ管理 | ガベージコレクション | ガベージコレクション | 効率的なGC |
| 型チェック | 実行時 | コンパイル時 | コンパイル時 |
| 最適化 | JIT（実行時） | JIT（実行時） | AOT（コンパイル時） |

### 実行速度の制約要因
- TypeScript/JavaScriptの特性
  - 動的型付けによる実行時チェック
  - プロトタイプベースの継承
  - 柔軟なオブジェクト操作
- V8エンジンの制約
  - JITコンパイルの限界
    - コンパイルプロセスの違い
      - Java
        - コンパイル時：Java → バイトコード（中間言語）
          - 静的型付けによる型の確定
          - 高度な最適化の準備
          - 型情報の保持
        - 実行時：バイトコード → マシンコード
          - 型情報を活用した効率的な最適化
          - 高度な最適化技術の適用
          - 最小限の実行時オーバーヘッド
      - Node.js/TypeScript
        - コンパイル時：TypeScript → JavaScript
          - 型チェックのみ
          - 型情報は実行時には保持されない
          - 最適化の準備が限定的
        - 実行時：JavaScript → マシンコード
          - 動的型付けによる制約
          - 実行時型チェックの必要性
          - 大きな実行時オーバーヘッド
    - パフォーマンスへの影響
      - 型情報の扱い
        - Java
          - コンパイル時に型が確定
          - 型情報を活用した最適化
          - 実行時型チェックが不要
        - JavaScript
          - 実行時に型を推論
          - 型情報の欠如による最適化の制限
          - 実行時型チェックのオーバーヘッド
      - 最適化の効率
        - Java
          - 効率的な最適化が可能
          - 高度な最適化技術の適用
          - 安定したパフォーマンス
        - JavaScript
          - 制約の多い最適化
          - 実行時型チェックの必要性
          - パフォーマンスの不安定性
      - 実行時オーバーヘッド
        - Java
          - 最小限のオーバーヘッド
          - 予測可能なパフォーマンス
          - 効率的なメモリ管理
        - JavaScript
          - 型チェックなどの追加コスト
          - 予測困難なパフォーマンス
          - メモリ管理のオーバーヘッド
  - ガベージコレクションのオーバーヘッド
  - シングルスレッド実行モデル

### 最適化の限界
- 言語設計の制約
  - 動的型付けによる実行時オーバーヘッド
  - 柔軟性と引き換えのパフォーマンス
  - ガベージコレクションの不可避性
- 実行環境の制約
  - V8エンジンの最適化限界
  - シングルスレッドモデルの制約
  - メモリ管理の柔軟性

### 推奨される方針
- パフォーマンスが重要な処理
  - 計算処理は別の言語で実装
  - マイクロサービスアーキテクチャの採用
  - 適切な技術選定
- Node.js/TypeScriptの活用
  - I/Oバウンドな処理
  - 非同期処理の活用
  - イベント駆動型の処理

## パフォーマンスの測定と対策
[ZOZOTOWNによる調査](https://techblog.zozo.com/entry/replacing-zozo-with-nextjs-knowledge)によると、Next.jsである程度のパフォーマンスを実現可能。
>高負荷の場合はパフォーマンス基準を安定的に満たし、スループットは5req/secと効率が悪い結果となりました。やはり前述した通り、CPUバウンドなSSRになってしまうとインフラのコストパフォーマンスは悪くなりそうです。しかし、中程度の負荷であれば、スループットも性能はまずまずという結果も得られました。この結果から、負荷を考慮したSSR実装をすることに加え、負荷増加が考えられるリリースをする際には負荷試験を行ない事前に検知するなど対策すればスケーラブルに運用できるという判断をしました。

>性能は常に最適な状態に保つことが望ましいため、CDNでキャッシュを使用することでパフォーマンスを向上し、コスト削減を実現できます。HTMLをSSRした結果を一定期間CDNでキャッシュすることにより、オリジンサーバー上でNode.jsサーバーの負荷を大幅に軽減できます。ただし、パフォーマンス要件を満たすためにキャッシュを有効にできない場合もあります。ホーム画面の要件に関してはキャッシュが可能であるため、キャッシュを有効にしています。具体的には、下記のようにレスポンスヘッダーのCache-Controlを使用して、キャッシュの保持期間を制御できます。（略）ただし、CDNキャッシュを利用する際には注意が必要です。特に、SSRするHTMLには個人を特定できるようなパーソナルな情報を含めないようにすることが重要です。ユーザーごとに異なるパーソナル情報はAPIから取得し、クライアントサイドでレンダリングするようにする必要があります。

### CDNの有無に関わらず有効なキャッシュ制御
- ブラウザキャッシュの仕組み
  - Cache-Controlヘッダーによる制御
    - キャッシュの有効期間を指定
    - ブラウザは指定期間中はサーバーにリクエストを送信しない
    - キャッシュされたレスポンスを直接使用
  - 制御方法
    ```typescript
    // app/page.tsxでの設定例
    export default function Page() {
      return <div>...</div>
    }

    // ページコンポーネントからキャッシュ時間を渡す
    export async function generateMetadata({ params, searchParams }) {
      // ページコンポーネントから渡されたキャッシュ時間を使用
      const cacheTime = searchParams.cacheTime || 3600 // デフォルト1時間
      
      return {
        other: {
          'Cache-Control': `public, max-age=${cacheTime}`
        }
      }
    }

    // または、ページコンポーネントで直接ヘッダーを設定
    export default async function Page() {
      const headers = new Headers()
      headers.set('Cache-Control', 'public, max-age=3600')
      
      return (
        <div>
          {/* コンテンツ */}
        </div>
      )
    }
    ```
  - キャッシュの効果
    - サーバーへのリクエスト削減
    - ページロード時間の短縮
    - サーバー負荷の軽減

- ISRとブラウザキャッシュの比較
  - ISR（Incremental Static Regeneration）
    - サーバーサイドでのキャッシュ
    - 定期的な再生成が必要
    - サーバーリソースを消費
    - グローバルなキャッシュ（全ユーザーで共有）
  - ブラウザキャッシュ
    - クライアントサイドでのキャッシュ
    - サーバーへのリクエストが発生しない
    - サーバーリソースを消費しない
    - ユーザーごとのキャッシュ
  - 使い分け
    - ブラウザキャッシュ
      - パーソナライズされていないコンテンツ
      - 更新頻度が低いコンテンツ
      - サーバー負荷を最小限に抑えたい場合
    - ISR
      - 全ユーザーで共有するコンテンツ
      - 定期的な更新が必要なコンテンツ
      - SEOが重要な場合